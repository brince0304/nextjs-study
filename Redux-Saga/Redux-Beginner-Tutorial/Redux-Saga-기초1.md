# Redux 사용 이유 ?

---

Props Drilling 을 최소화 하기 위해

ContextApi 를 사용시에는 고차 컴포넌트가 될 가능성이 높으나 리덕스를 사용하면 하나의 프로바이더로 해결이 가능하다.

## Flux 패턴

`Action -> Dispatch -> Store -> View` 의 흐름으로 단방향으로 흐르게 된다.

뷰에서 store 의 상태를 변경하는 dispatch 함수를 통해 action 함수가 발동되고 store 의 상태가 변경, 해당 상태를 구독하는 컴포넌트가 변하는 단방향 흐름을 가진다.

## 불변성을 지켜야 하는 이유

단순히 불필요한 리렌더링을 방지하기 위해

# 사가 기초

---

→ Redux 는 무조건 동기적으로 dispatch 가 이뤄지고 dispatch 를 여러번 할 경우 컴포넌트 파일에서 dispatch 로직을 2번 써야한다. 그래서 나온 미들웨어가 redux-saga 이다.

Redux-saga 는 비동기적으로 dispatch를 수행 (put) , 동일한 API를 여러번 요청할 경우 가장 최근 혹은 마지막 결과만 받아오도록 (takeleast, thuttle, debounce) 하는 기능도 존재한다.

## 미들웨어란 ?

→ 미들웨어는 Redux 스토어에서 액션이 디스패치되어 리듀서에 도달하기 전에 중간에서 처리하는 로직을 추가할 수 있는 **확장성 있는 구조**를 뜻합니다. Redux-saga는 Redux 미들웨어 중 하나로, 비동기적으로 디스패치를 수행하고, 동일한 API를 여러 번 요청할 경우 가장 최근이나 마지막 결과만 받아오도록 설정할 수 있는 기능을 제공합니다. 주로 비동기 작업 / 로깅 / 라우팅 등의 기능을 처리할 때 유용하게 사용된다.

## 리덕스 사가의 특징?

→ 액션을 모니터링하고 특정 액션이 디스패치 될 때 특정 작업을 수행할 수 있다.

(어떻게보면 로직 자체가 Axios 의 Interceptor 과 비슷하다.)

Saga를 실행하려면 다음을 수행해야 한다:

- Saga 미들웨어를 생성한다.
- Saga 미들웨어를 Redux 스토어에 연결한다.

# Saga 모듈 만들기

---

- API 로직을 연동시킨다.
- 제네레이터 함수를 선언한다.
    - API 통신을 할땐 `call()` 를 사용한다.
    - `yield` 키워드와 `put()` 를 호출하여 dispatch
    - 가장 최근 요청에 대한 결과를 반환할때는 `takeLatest()`

put()을 실행하면 타입 파라미터로 념겨진 타입을 구독하고있는 reducer가 반응한다.

→ 같은 액션을 사가나 리듀서에서 동시에 실행하면 순서는 리듀서가 먼저 실행된다.

# Saga 이펙트 함수

---

- `all()` → 배열을 받아 받은 이펙트를 **등록**한다.
- `fork()` → 함수를 실행한다.
- `call()` → 동기 함수를 호출한다. (리턴때까지 기다린다.) `fork()` 는 비동기 함수를 호출한다. (안기다리고 이동) / 통신할땐 무조건 `call()` 를 사용한다.
- `take()` → 한번만 실행 후 이벤트가 삭제된다.
- `takeEvery()` → 한번 실행되어도 계속 실행한다.
- `takeLatest()` → 마지막 이벤트만 실행한다.
    - 클라이언트에서 서버로 요청은 실행된만큼 보내지만 서버에서 클라이언트로는 마지막 한번만 결과를 반환한다.
    - 해당 부분을 보완하기 위해 throttle이 존재한다.
- `throttle()` → 1초 이내에 요청을 한번만 실행한다.  (무한 스크롤 같은 요청에 굳)
- `debounce()` → ~초 이내에 요청을 한번만 실행한다. (검색 자동완선 같은 요청에 굳)
- `takeLeading()` → 첫번째 이벤트만 실행한다.